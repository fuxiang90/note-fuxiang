
总体来说，这本书一般，有很多内容我也不能理解的很深，从图书馆借的书，看几天就准备还了。


1. 构造函数
某个循环执行100万次，添加一个临时对象 运行时间为0.14s ，没有添加的为0.014，大概相差十倍

2. 虚函数
* 对于虚函数而言如果使用虚函数，会增加虚函数表指针的开销，并且每次访问函数的时候需要进行一次寻址

3. 返回值优化
* 

4. 临时对象
* 在不影响程序的前提下，尽量避免使用临时对象。但是有的时候会导致程序的结构不是很好
> sum = a+b 就产生了临时对象 使用sum = a sum+= b ，但是对于现在的编译器和 cpu 计算能力来说并不提倡

5. 内存池 
* 这个看的不是很仔细，对于单线程和多线程来说，肯定不同，使用内部lock ，
* 对内存的频繁申请，是一个开销很大的事情。

6. 内联函数
* 讲了很多，这确实是一个很好的优化措施，减少函数调用的开销，但是同时的隐患是在预处理阶段需要将函数进行展开，那么就会增加
编译所使用的时间。
7.  标准模板库
* 很早以前看stl 的书，就被传导一个这样的概念，很多程序员写出的程序是没有stl的实现的高效，当然这里也重申了一下，但是同时也说
如果我们对我们自己程序的使用环境够清晰，并且知道stl的实现内幕，或许你可以写出比stl 更高效的程序，因为stl 是模板，他照顾了太多
的情况，肯定是要丧失一定的性能。
* 比较 数组，vector list 插入数据 和 删除数据的性能，这个如果了解stl的底层实现的话就不难理解了

8. 编码优化
* 缓存，这个是很多优化的措施 
* 预先计算，不要等到需要计算的时候才计算
* 降低灵活性，通常是减少一些new 的开销
* 80-20 的法则，往往80%的时间是浪费在20% 的程序上，专注这20%的程序，对性能的提升会更明显
* 延迟计算

